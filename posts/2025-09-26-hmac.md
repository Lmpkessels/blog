---
title: HMAC implementation for SHA256
html_title: HMAC for SHA256 | Lmpkessels
description: Step-by-step HMAC implementation in Rust using SHA256. Includes Rust code examples, key normalization, XOR with ipad/opad, and test verification.
section: cryptography
image: /assets/hmac-sha256-thumb.jpg
alternative: Dark minimalist thumbnail showing binary code with bold text: HMAC SHA256 Rust.
date: 2025-09-26
slug: hmac-for-sha256
---

HMAC (Hash Message Authentication Code) is a mechanism that combines a cryptographic hash function with a secret key. It ensures authenticity (the user knows it came from the right sender) and integrity (the user knows it wasn’t changed).

In real-world usage, every secure **API call**, **crypto wallet**, or **payment processor** you use today relies on HMAC. Without it, attackers could forge requests or alter data.

Let's start with the 9 primitives used in **HMAC**.

## The 9 primitives used in HMAC

<ol class="post-ol">
    <li>check the size of the block (b bytes).</li>
    <li>a key (K).</li>
    <li>a fixed-size key (k0), identical to the block size.</li>
    <li>ipad (inner padding).</li>
    <li>opad (outer padding).</li>
    <li>XOR logic (to flip the bits).</li>
    <li>a message in bytes.</li>
    <li>appending.</li>
    <li>the hash function of choice (for this blog that'll be SHA256).</li>
</ol>

Now you know the 9 primitives used in **HMAC**, let's look at how the key is **normalized** to **k0** so it matches the block-bytes (64 bytes for SHA256).

## Normalizing k0 to b-bytes

First we make sure the key matches the right block-size (b-bytes) equaling 64 bytes or 512 bits, since 64 \* 8 = 512. We use **if else logic** to normalize the key to the right size.

Here is the **if else logic** we use to normalize the key to variable k0.

<ul class="post-ul">
  <li><b>If</b> k is equal to b bytes, then k becomes k0</li>
  <li><b>If</b> k is less than b bytes, append all 0s to k until k is b bytes (for SHA256 if k is 23 bytes or 184 bits than append 41 bytes or 328 bits to k) then k becomes k0.</li>
  <li><b>If</b> k is greater than b-bytes hash k such that k becomes less than b-bytes and append all 0s to make k equal to b-bytes, then k becomes k0.</li>
</ul>

Let's look at **_Figure 1.0_** to see how it looks in Rust:

<figure>
<pre><code class="language-rust">
pub fn get_right_block_size(k: &[u8]) -> Vec<u8> {
    let mut k0: Vec<u8> = k.to_vec();
    let mut key_length = k0.len();
    let block_size = 64;
    
    // k = k0 if key length == block_size.
    if key_length == block_size {
        return k0;
    };
    
    // Hash k0 and append 0s if key_length > block_size.
    if key_length > block_size {
        k0 = sha256(&k0).to_vec();
        let mut k_l = k0.len();
        while k_l < block_size {
            k0.push(0x00);
            k_l += 1;
        };
    };

    // Append all 0s if key_length < block_size.
    if key_length < block_size {
        let mut k_l = k.len();
        while k_l < block_size {
            k0.push(0x00);
            k_l += 1;
        };
    };

    k0

}
</code></pre>

<figcaption><b>Figure 1.0</b>: Rust code normalizing HMAC keys for SHA256</figcaption>
</figure>

Now, depending on the size of the key, an **if** branch is chosen and the key is normalized to the right size.

When the key is normalized, we use it with **ipad, opad, XOR**, and **the message** to **authenticate the message**. Let's look at Authenticating the key so you can see how the process takes place.

## Authenticating the key

To authenticate the key we use **ipad** (inner padding) which is an array of **64 times x'36'** (HEX 36; 0011_0110) which is **XOR'd with the normalized key**, and stored in an array of 64 bytes with the updated **HEX values** after **ipad ^ k0** is computed.

After updating the array with **ipad ^ k0** we append the message to the updated array, and then **((ipad ^ k0) || msg) is hashed with SHA256**, in equation it's: **SHA256((ipad ^ k0) || msg)**.

For **opad** (outer padding) we repeat the same process, **opad** is an array that contains **64 times x'5c'** (HEX 5c; 0101_1100) those hex values are **XOR'd with the normalized key (k0)**, after k0 is authenticated with opad, it gets stored in an array with the updated **HEX values** after the computation **opad ^ k0**.

Let's look at the bigger picture in **_figure 1.1_** where the HMAC flow is displayed.

<figure>
<pre class="diagram-block">
            Key (K)
              |
       Normalize to blocksize
              ↓
            K0
              |
   ┌──────────┴──────────┐
   │                     │
K0 ⊕ ipad           K0 ⊕ opad
   │                     │
   + Message             + (Hash of left side)
   │                     │
   SHA256 ---------------┘
              ↓
         Final HMAC
</pre>

<figcaption><b>Figure 1.1:</b></figcaption>
</figure>

Now you've seen the flow of HMAC in figure 1.1., let's take a look at **_figure 1.2_** where you'll see it programmed in **Rust**.

<figure>
<pre><code class="language-rust">
pub fn hmac(k: &[u8], m: &[u8]) -> [u8; 32] {
    let mut result: Vec<u8> = Vec::new();
    let mut ipad: Vec<u8> = vec![0x36u8; 64];
    let mut opad: Vec<u8> = vec![0x5cu8; 64];

    // Vector ipad[i] and opad[i] XORed with k[i].
    for i in 0..64 {
        ipad[i] ^= k[i];
        opad[i] ^= k[i];
    };

    let msg: Vec<u8> = m.to_vec();
    let msg_len = m.len();

    // ((K0 ^ ipad) || text)).
    let mut j = 0;
    while j < msg_len {
        ipad.push(msg[j]);
        j += 1;
    };

    // H((K0 ^ ipad) || text)).
    let sha = sha256(&ipad);

    // ((K0 ^ opad )|| H((K0 ^ ipad) || text))
    for k in 0..32 {
        opad.push(sha[k]);
    };

    // h((K0 ^ opad )|| H((K0 ^ ipad) || text)).
    sha256(&opad)

}
</code></pre>

<figcaption><b>Figure 1.2</b>: Inner and outer pad authentication process in Rust</figcaption>
</figure>

After this process, we append the equation **SHA256((ipad ^ K0) || msg)** to **(opad ^ K0)** after that we have **((opad ^ k) || SHA256((ipad ^ k) || msg))**.

When we append opad to ipad the equation is hashed again: **SHA256((opad ^ k) || SHA256((ipad ^ k) || msg))**, and the final HMAC is a 32-byte output (since SHA-256 always returns 256 bits).

In **_figure 1.3_** you can read an edge test case as a visual example, programmed in **Rust** to verify correctness.

<figure>
<pre><code class="language-rust">
#[test]
fn brown_fox() {
    let k = get_right_block_size(b"key");
    let msg = b"The quick brown fox jumps over the lazy dog";

    let result = hmac(&k, msg);
    let expected = [
      0xf7, 0xbc, 0x83, 0xf4, 0x30, 0x53, 0x84, 0x24,
      0xb1, 0x32, 0x98, 0xe6, 0xaa, 0x6f, 0xb1, 0x43,
      0xef, 0x4d, 0x59, 0xa1, 0x49, 0x46, 0x17, 0x59,
      0x97, 0x47, 0x9d, 0xbc, 0x2d, 0x1a, 0x3c, 0xd8,
    ];

    assert_eq!((result), (expected));

}

</code></pre>

<figcaption><b>Figure 1.3</b>: Edge test verifying correctness of HMAC implementation</figcaption>
</figure>

If you’d like a deeper dive into edge test cases, take a look at [RFT Home](https://www.rfc-editor.org/rfc/rfc4231) this is the website where I got the tests.

That’s it. Now you know how **HMAC authenticates your key with SHA256**.

## Closing

If you're into Systems Thinking, Clear Thinking, Rust, Crypto, and Philosophy, check out <a href="https://x.com/lmpkessels" target="_blank" rel="noopener noreferrer"><em>X/Twitter</em></a>, here I’ll share thoughts and update when new blogs go live.

For the full Rust HMAC SHA256 implementation, check out my repo <a href="https://github.com/Lmpkessels/crypto-primitives.git" target="_blank" rel="noopener noreferrer"><em>crypto-primitives</em></a> to see (or clone) the repository.

If you're building in the crypto space and see areas for improvement, reach me at: [l@lmpkessels.com](mailto:l@lmpkessels.com) or, send me a DM on <a href="https://x.com/lmpkessels" target="_blank" rel="noopener noreferrer"><em>X/Twitter</em></a>.

Until the next one.
