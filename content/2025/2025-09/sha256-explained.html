<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SHA256 Explained | Lmpkessels</title>
    <link rel="canonical" href="https://lmpkessels.com/content/2025/2025-09/sha256-explained.html" />
    <meta name="description" content="Understand SHA-256 step by step: padding, scheduling, and compression. Clear explanation of how this hash algorithm secures Bitcoin and data." />

    <!-- Open Graph / Twitter -->
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Step-by-step explanation of SHA256" />
    <meta property="og:description" content="Understand SHA-256 step by step: padding, scheduling, and compression. Clear explanation of how this hash algorithm secures Bitcoin and data." />
    <meta property="og:url" content="https://lmpkessels.com/content/2025/2025-09/sha256-explained.html" />
    <meta property="og:image" content="https://lmpkessels.com//assets/thumbnail-sha-256.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Step-by-step explanation of SHA256" />
    <meta name="twitter:description" content="Understand SHA-256 step by step: padding, scheduling, and compression. Clear explanation of how this hash algorithm secures Bitcoin and data." />
    <meta name="twitter:image" content="https://lmpkessels.com//assets/thumbnail-sha-256.png" />
    <meta name="twitter:image:alt" content="Minimalist SHA256 blog thumbnail with white text on a dark gray background and faint binary code pattern. Bold 'SHA256' stands out in the center." />
    <meta property="article:published_time" content="2025 Sep 18" />

    <link
      href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-rust.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito+Sans:ital,opsz,wght@0,6..12,200..1000;1,6..12,200..1000"
      rel="stylesheet"
    />
    <link rel="icon" href="/assets/lmpk-logo.ico" type="image/x-icon" />
    <!-- IMPORTANT: point this at your published CSS path -->
    <!-- If Netlify publishes /content, keep href="/style.css" and place style.css in /content -->
    <link rel="stylesheet" href="/style.css" />
    <!-- If you really keep it in /dist/style.css, change publish dir or this href accordingly. -->

    <!-- Theme bootstrap -->
    <script>
      const savedTheme = localStorage.getItem("theme");
      const prefersDark =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;
      if (savedTheme === "dark" || (!savedTheme && prefersDark)) {
        document.documentElement.classList.remove("default-mode");
      } else {
        document.documentElement.classList.add("default-mode");
      }
    </script>
  </head>
  <body>
    <div class="page-container">
      <div class="content-wrapper">
        <header>
          <!-- Light / dark toggle -->
          <div class="light-dark-toggle" id="theme-toggle">
            <noscript>Toggle not shown. JavaScript disabled.</noscript>
            <!-- Sun -->
            <svg
              class="toggle-sun"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"
              />
            </svg>
            <!-- Toggle -->
            <div class="toggle-wrapper">
              <div class="toggle-knob"></div>
            </div>
            <!-- Moon -->
            <svg
              class="toggle-moon"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z"
              />
            </svg>
          </div>

          <!-- Title + meta -->
          <div class="header-full-post">
            <h1>Step-by-step explanation of SHA256</h1>
          </div>
          <div class="date-and-link">
            <p class="post-date"><time datetime="2025 Sep 18">2025 Sep 18</time></p>
            <a href="/index.html" class="nav-anchor">All posts</a>
          </div>
        </header>
        <br />
        <br />
        <br />
        <br />

        <!-- >>> The Markdown content goes right here <<< -->
        <main class="post-body"><p>In today’s information age we need security for our passwords, online transactions, repositories, emails and more. That security is developed with the use of the hash algorithm <strong>SHA256</strong> standardized by <strong>NIST in FIPS 180-4</strong>.</p>
<p>Let's start with preprocessing the message.</p>
<h2>Preprocessing the message</h2>
<p>When the message is received in bytes at the parameter of <strong>SHA256</strong> a few steps are taken before scheduling. Starting with counting the message length.</p>
<p>The <strong>message length is counted in bytes</strong> (bytes are base-2 strings of 8-bits 0s and 1s) if the message is <strong>"abc" then the count is 24 bits</strong>. At the end of each message we <strong>pad 1 bit (0x80 in HEX)</strong>.</p>
<p>After the message length is counted and 1 is padded, we <strong>pad all 0s (K) till the size ≡ 448 (mod 512)</strong>, leaving <strong>64 bits free for the counted message length in two 32-bit words (64 bits)</strong>.</p>
<p>When padding the message is done the block is parsed into 16 - 32-bit words, of which 14 contain the message, and the last <strong>2 words contain the message length in big-endian order</strong> (big-endian order means that the MSB is stored in the lowest address and the LSB is stored in the highest level address in register).</p>
<p>After we've padded and parsed the message and stored it in the block, we're ready to schedule the block into 64 - 32-bit words.</p>
<h2>Scheduling the message</h2>
<p>When the message is scheduled, the pre-processed block is taken and looped through to take each 32-bit word one-by-one out of the block. Then each of the 16 32-bit words get stored at index 0..15.</p>
<p>After we've stored the 16 32-bit words at index 0..15 we're going to take those words and fill index 16..63, we do this by applying <strong>σ₁ and σ₀</strong> (σ₁ stands for small sigma 1, and σ₀ for small sigma 0).</p>
<p><i><b>NOTE:</b> All additions are done with modulo 2<sup>32</sup>.</i></p>
<p><strong>σ₁ rotates index-2 right 17 index positions</strong> (meaning it shifts to right 17 times and every bit that shifts outside of the 32-bit word gets appended to the left side of the word) after ROTR <strong>XOR is applied</strong> (XOR flips the bit in the 32-bit word bit-by-bit, 1 XOR 0 = 1, 0 XOR 1 = 1, 1 XOR 1 = 0, 0 XOR 0 = 0) after each bit is flipped we <strong>rotate index-2 right 19 times XOR is applied</strong> for the last time, then <strong>index-2 is shifted right 10 times</strong> (shift right lets the bits fall off the 32-bit word), and return the <strong>result of σ₁ + 32-bit word at index-7</strong>.</p>
<p>After that <strong>σ₀</strong> is applied (σ₀ stands for small sigma 0), <strong>σ₀ rotates index-15 right 7 times</strong> while <strong>XOR flips the bits again</strong> then ROTR <strong>rotates index-15 right 18 times, XOR is applied one last time, then index-15 is shifted right 3 times</strong> and, the <strong>result of σ₀ + 32-bit word at index-16</strong> is returned.</p>
<p>From index 16..63 the words received as output from σ₁ and σ₀ are stored as the scheduled message.</p>
<p>So index 0..15 contain the 16 32-bit m-block words and 16..63 the scheduled version of the 16 32-bit m-block words.</p>
<p>Now the message (M) is scheduled we arrive at the last layer of the algorithm, <strong>compression</strong>.</p>
<h2>Compression function</h2>
<p>The compression part of the secure hash algorithm is where its power is found.</p>
<p>First we start at the <strong>64 round constants (words)</strong> (K) which are declared and represent the first thirty-two bits of the fractional parts of the cube roots of the first sixty-four prime numbers, (resource FIPS 180-4 (NIST)).</p>
<p>Second the <strong>8 words of initial hash values</strong> {h0, h1, ..., h6, h7} are declared. The initial hash values consist of the eight 32-bit words in hex, which are gained by taking the first thirty-two bits of the fractional parts of the square roots of the first eight prime numbers (resource FIPS 180-4 (NIST)).</p>
<p>Third the <strong>8 working word variables</strong> are declared {a, b, ..., g, h}, and <strong>two temporary words</strong> (T1, T2).</p>
<p>We start with assigning the <strong>8 initial hash values</strong> (h0..h7) to the <strong>8 working variables</strong> (a..h). Where <strong>{h0=a, h1=b, h2=c, h3=d, h4=e, h5=f, h6=g, h7=h}</strong>. The two temporary words use modulo, Σ₁, Σ₀, Ch, Maj, the 64 round constant (K), and the scheduled message (M).</p>
<p>To access each index in K and M and compress the message a 0..63 round loop is used.</p>
<p><i><b>NOTE:</b> All additions are done with modulo 2<sup>32</sup>.</i></p>
<ul class="post-ul">
  <li><b>T1 = </b>h + Σ₁(e) + Ch(e,f,g) + K[i] + M[i]</li>
  <li><b>T2 = </b>Σ₀(a) + Maj(a,b,c)</li>
</ul>

<p><em><strong>NOTE:</strong> All of this works at the bit level with boolean logic so if we have NOT(A) where A = 0101, then a becomes 1010.</em></p>
<p><em><strong>NOTE:</strong> Σ (big sigma) functions are different from σ (small sigma).</em></p>
<ul class="post-ul">
    <li>Σ₀ rotates <b>word a</b> right 2 times applies XOR, then rotates <b>word a</b> right 13 times applies XOR, then rotates <b>word a</b> right 22 times, and returns the result of Σ₀.</li>
    <li>Σ₁ rotates <b>word e</b> right 6 times applies XOR, then rotates <b>word e</b> right 11 times applies XOR, then rotates <b>word e</b> right 25 times, and returns the result of Σ₁.</li>
    <li>For Ch <b>word e</b> is <b>simulated bit-by-bit</b> against <b>word f</b> while <b>boolean expression AND is applied</b>, then XOR is applied <b>word e</b> the <b>boolean expression NOT is applied on the entire word</b> then the word is taken and simulated bit-by-bit against the <b>word g</b> while <b>boolean expression AND is applied</b> and returns the result of Ch.</li>
    <li>For Maj <b>word a</b> is <b>simulated bit-by-bit</b> against <b>word b</b> while <b>boolean expression AND is applied</b>, then XOR is applied and the process is repeated for <b>word a</b> and <b>word c</b>, then XOR is applied and the process is repeated for word <b>b</b> and <b>word c</b>, and returns the result of Maj.</li>
</ul>

<p><em><strong>NOTE:</strong> Σ (big sigma) functions are different from σ (small sigma).</em></p>
<p>Expanding on the round operation, <strong>h = g, g = f, f = e, e = d + T1, d = c, c = b, b = a, a = T1 + T2</strong>.</p>
<p>In the <strong>final step</strong>, the i-th intermediate hash value (Hi) is computed by assigning the initial hash values {h0, .., h7} to {h0..h7 + a..f} where:</p>
<figure>
  <table class="table-175px">
    <tbody>
      <tr><td>h0 = h0 + a</td></tr>
      <tr><td>h1 = h1 + b</td></tr>
      <tr><td>h2 = h2 + c</td></tr>
      <tr><td>h3 = h3 + d</td></tr>
      <tr><td>h4 = h4 + e</td></tr>
      <tr><td>h5 = h5 + f</td></tr>
      <tr><td>h6 = h6 + g</td></tr>
      <tr><td>h7 = h7 + h</td></tr>
    </tbody>
  </table>
  <figcaption><b>Final update step:</b> Each working variable is merged back into the hash state.</figcaption>
</figure>

<p>Then <strong>the message is digested by appending [h0, h1, h2, h3, h4, h5, h6, h7]</strong> to return the final <strong>256-bit key</strong>.</p>
<p>That's SHA256 explained.</p>
<h2>Closing</h2>
<p>If you want to stay updated on topics like Systems Thinking, Clear Thinking, Rust, Crypto, and Philosophy, check out <a href="https://x.com/lmpkessels" target="_blank" rel="noopener noreferrer"><em>X/Twitter</em></a>, here I’ll update you when new blogs go live.</p>
<p>If you want to see programmed examples <a href="https://github.com/Lmpkessels/crypto-primitives.git" target="_blank" rel="noopener noreferrer"><em>Click Here</em></a> to go to the repository.</p>
<p>If you're building in the crypto space and see some major improvement or if you're just curious and want to connect with a like minded individual,</p>
<p>You can reach me at <a href="mailto:l@lmpkessels.com">l@lmpkessels.com</a> or, send me a DM on <a href="https://x.com/lmpkessels" target="_blank" rel="noopener noreferrer"><em>X/Twitter</em></a>.</p></main>
      </div>
    </div>

    <!-- Toggle script -->
    <script>
      const toggle = document.getElementById("theme-toggle");
      toggle.addEventListener("click", () => {
        document.documentElement.classList.toggle("default-mode");
        const mode = document.documentElement.classList.contains("default-mode")
          ? "light"
          : "dark";
        localStorage.setItem("theme", mode);
      });
    </script>
  </body>
</html>
