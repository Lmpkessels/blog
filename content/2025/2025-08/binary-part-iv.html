<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Binary part-IV</title>
    <link rel="canonical" href="https://lmpkessels.com/content/2025/2025-08/binary-part-iv.html" />
    <meta name="description" content="Binary multiplication from first principles: AND, SHIFT, ADD. Full worked example 5×10, plus short recap on addition logic" />

    <!-- Open Graph / Twitter -->
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Binary multiplication explained" />
    <meta property="og:description" content="Binary multiplication from first principles: AND, SHIFT, ADD. Full worked example 5×10, plus short recap on addition logic" />
    <meta property="og:url" content="https://lmpkessels.com/content/2025/2025-08/binary-part-iv.html" />
    <meta property="og:image" content="https://lmpkessels.com/assets/binary-multiply-thumb.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Binary multiplication explained" />
    <meta name="twitter:description" content="Binary multiplication from first principles: AND, SHIFT, ADD. Full worked example 5×10, plus short recap on addition logic" />
    <meta name="twitter:image" content="https://lmpkessels.com/assets/binary-multiply-thumb.png" />
    <meta name="twitter:image:alt" content="Binary multiplication: AND • SHIFT • ADD with 0101 × 1010 = 0110010 (50)" />
    <meta property="article:published_time" content="2025 Aug 23" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito+Sans:ital,opsz,wght@0,6..12,200..1000;1,6..12,200..1000"
      rel="stylesheet"
    />
    <link rel="icon" href="/assets/lmpk-logo.ico" type="image/x-icon" />
    <!-- IMPORTANT: point this at your published CSS path -->
    <!-- If Netlify publishes /content, keep href="/style.css" and place style.css in /content -->
    <link rel="stylesheet" href="/style.css" />
    <!-- If you really keep it in /dist/style.css, change publish dir or this href accordingly. -->

    <!-- Theme bootstrap -->
    <script>
      const savedTheme = localStorage.getItem("theme");
      const prefersDark =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;
      if (savedTheme === "dark" || (!savedTheme && prefersDark)) {
        document.documentElement.classList.remove("default-mode");
      } else {
        document.documentElement.classList.add("default-mode");
      }
    </script>
  </head>
  <body>
    <div class="page-container">
      <div class="content-wrapper">
        <header>
          <!-- Light / dark toggle -->
          <div class="light-dark-toggle" id="theme-toggle">
            <noscript>Toggle not shown. JavaScript disabled.</noscript>
            <!-- Sun -->
            <svg
              class="toggle-sun"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"
              />
            </svg>
            <!-- Toggle -->
            <div class="toggle-wrapper">
              <div class="toggle-knob"></div>
            </div>
            <!-- Moon -->
            <svg
              class="toggle-moon"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z"
              />
            </svg>
          </div>

          <!-- Title + meta -->
          <div class="header-full-post">
            <h1>Binary multiplication explained</h1>
          </div>
          <div class="date-and-link">
            <p class="post-date"><time datetime="2025 Aug 23">2025 Aug 23</time></p>
            <a href="/index.html" class="nav-anchor">All posts</a>
          </div>
        </header>
        <br />
        <br />
        <br />
        <br />

        <!-- >>> The Markdown content goes right here <<< -->
        <main class="post-body"><p>At the heart of computer performance lies binary multiplication, the process of combining numbers bit-by-bit.</p>
<p>Let's take a look at how it works.</p>
<h2>1st principles of binary multiplication</h2>
<p>To break it down, here you have the three logical operations used in binary multiplication, <strong>AND, SHIFT, ADD</strong>.</p>
<ul class="post-ul">
  <li><b>AND</b>: takes <b>each bit of B in isolation</b> and applies <b>AND</b> on the entire string of A <b>bit-by-bit</b>.</li>
  <li><b>SHIFT</b>: Shift Left is performed every move down starting from 0, till all moves <i>(based on the range of B)</i> are performed.</li>
  <li><b>ADD</b>: is used to add up the whole and get the product Sum in return.</li>
</ul>

<p>For each bit of <strong>B</strong> (index i) we perform a move down, every move down is a Shift Left (starting at index 0) which creates a partial. Every partial is summed up using addition logic to get the multiplication end product.</p>
<p>Let me walk you through an example using 5 X 10 (0101 X 1010) starting at <em>figure 1.0</em>.</p>
<ul class="post-ul">
  <li><b>A</b> is 0101 (5)</li>
  <li><b>B</b> is 1010 (10)</li>
</ul>

<figure>
  <table>
    <thead>
      <tr>
        <th>Bit position</th>
        <th>B[i]</th>
        <th>(B[i] AND A)</th>
        <th>Shift (<< i)</th>
        <th>Partial product (7b)</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>0</td><td>0</td><td>0000</td><td><< 0</td><td>XXX0000</td></tr>
      <tr><td>1</td><td>1</td><td>0101</td><td><< 1</td><td>XX01010</td></tr>
      <tr><td>2</td><td>0</td><td>0000</td><td><< 2</td><td>X000000</td></tr>
      <tr><td>3</td><td>1</td><td>0101</td><td><< 3</td><td>0101000</td></tr>
    </tbody>
  </table>
  <figcaption><b>Figure 1.0:</b> Step table: for each bit of B, AND it with A, then shift left by its index to form a partial product.</figcaption>
</figure>

<p>We mark unused positions with <strong>X which act as placeholders, in actual hardware these become 0s in register</strong>. So that the ALU can work with the same range in every bit-by-bit addition calculation, to get Sum and Carry out.</p>
<p>If you're not familiar with binary addition check out <a href="https://lmpkessels.com/content/2025/2025-07/binary-part-ii">binary part-II</a>.</p>
<p>Now let's apply binary addition row-by-row on each partial product.</p>
<h2>Binary addition applied on Partial product</h2>
<p>Short recap of Sum, and Carry out:</p>
<ul class="post-ul">
  <li><b>Sum:</b> A XOR B XOR Carry in</li>
  <li><b>Carry out:</b> (A AND B) OR (Carry in AND (A XOR B))</li>
</ul>

<p><em><strong>Example:</strong> 1 + 1 with carry-in 0 gives sum = 0, carry = 1</em></p>
<p>Starting bit-by-bit at <strong>Partial 0, and 1</strong> in <em>figure 1.1</em>, to get the Sum column then we repeat that process two more times.</p>
<figure>
  <table>
    <thead>
      <tr>
        <th>Bit position</th>
        <th>Running sum</th>
        <th>Next partial</th>
        <th>Carry in</th>
        <th>Sum</th>
        <th>Carry out</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
      <tr><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>3</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
      <tr><td>4</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>5</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>6</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
    </tbody>
  </table>
  <figcaption><b>Figure 1.1:</b> Ripple-carry addition: adding Partial 0 and Partial 1 from Figure 1.0.</figcaption>
</figure>

<p><strong>NOTE:</strong> Bit 0 is rightmost least significant bit (LSB) moving to leftmost most significant bit (MSB).</p>
<p>Now in <em>figure 1.2</em> we take Sum from <em>figure 1.0</em> and apply addition logic bit-by-bit with <strong>Partial 2</strong> of <em>figure 1.0</em>.</p>
<figure>
  <table>
    <thead>
      <tr>
        <th>Bit position</th>
        <th>Running sum</th>
        <th>Next partial</th>
        <th>Carry in</th>
        <th>Sum</th>
        <th>Carry out</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
      <tr><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>3</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
      <tr><td>4</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>5</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>6</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
    </tbody>
  </table>
  <figcaption><b>Figure 1.2:</b> Ripple-carry addition: adding the previous sum with Partial 2 from Figure 1.0.</figcaption>
</figure>

<p>Arriving at the last Partial, <strong>Partial 3</strong> in <em>figure 1.0</em>, we repeat addition logic for Sum and Carry out one last time.</p>
<figure>
  <table>
    <thead>
      <tr>
        <th>Bit position</th>
        <th>Running sum</th>
        <th>Next partial</th>
        <th>Carry in</th>
        <th>Sum</th>
        <th>Carry out</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
      <tr><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
      <tr><td>3</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
      <tr><td>4</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
      <tr><td>5</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
      <tr><td>6</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
    </tbody>
  </table>
  <figcaption><b>Figure 1.3:</b> Ripple-carry addition: adding the running sum with Partial 3 from Figure 1.0 to produce the final product.</figcaption>
</figure>

<p>After applying addition logic on all four arrays we end up with <strong>'0110010'</strong> (you can read it in the Sum column), which is integer <strong>50</strong>.</p>
<p>That was binary multiplication.</p>
<p>Like to stay updated and learn about Systems, Rust, Math, and more? Then you can follow me on <a href="https://x.com/lmpkessels">X/Twitter</a> where I'll be posting when a blog goes live.</p>
<p>Want to see coded examples? Check, <a href="https://github.com/Lmpkessels/axiom.git">ALU</a> a 32-bit Arithmetic Logic Unit that goes from integers to bit-by-bit simulations through logic gates, supports ADD, SUB, MULTIPLY, DIV.</p>
<p>Now go practice some <em>binary multiplication</em> till next time.</p></main>
      </div>
    </div>

    <!-- Toggle script -->
    <script>
      const toggle = document.getElementById("theme-toggle");
      toggle.addEventListener("click", () => {
        document.documentElement.classList.toggle("default-mode");
        const mode = document.documentElement.classList.contains("default-mode")
          ? "light"
          : "dark";
        localStorage.setItem("theme", mode);
      });
    </script>
  </body>
</html>
